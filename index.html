<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="坚持与反复之后，柔水终成雕刀">
<meta property="og:type" content="website">
<meta property="og:title" content="柔水刻刀">
<meta property="og:url" content="http://pymonar.github.io/index.html">
<meta property="og:site_name" content="柔水刻刀">
<meta property="og:description" content="坚持与反复之后，柔水终成雕刀">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柔水刻刀">
<meta name="twitter:description" content="坚持与反复之后，柔水终成雕刀">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pymonar.github.io/"/>





  <title>柔水刻刀</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柔水刻刀</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2018/02/28/mymac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/mymac/" itemprop="url">你好，新战友！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T12:12:00+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前年就一直想买一台Macbook pro了，16年出了Touch-bar，那时候真是饥渴难耐。只是这两年来人生经历了很多大事，结婚买房装修，一直没有多余的钱去买电脑。直到今年初发了年终奖才有了结余，为了奖励自己，一咬牙买了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2017/10/30/closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/closure/" itemprop="url">闭包不完全指西</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-30T16:04:00+08:00">
                2017-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>理解闭包是前端开发工程师的基本。 ——鲁迅</p>
</blockquote>
<h2 id="1-闭包是什么"><a href="#1-闭包是什么" class="headerlink" title="1. 闭包是什么"></a>1. 闭包是什么</h2><p>要讲清楚闭包，首先要先从js的作用域说起。</p>
<p>js在运行之前会建立起一条<strong>作用域链</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> glob = <span class="string">'Global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> outer = <span class="string">'Outer'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> inner = <span class="string">'Inner'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的作用域链为<code>Global =&gt; Outer =&gt; Inner</code>，作用域链越靠近末端，可以访问的变量范围越大。任何一个函数可以访问其自己所在作用域中的变量以及父作用域中的变量，比如在<code>Inner</code>函数内部可以访问到<code>glob</code>、<code>outer</code>、<code>inner</code>三个变量。</p>
<p>函数无法访问自己子作用域中的任何变量，除非定义为全局的（不推荐）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> glob = <span class="string">'Global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> outer = <span class="string">'Outer'</span>;</span><br><span class="line">    <span class="comment">// console.log(inner); 无法访问</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> inner = <span class="string">'Inner'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(outer); 无法访问</span></span><br></pre></td></tr></table></figure>
<p>js中函数是一等公民，也就是说函数可以作为任何值被传递，所以看上边的例子，虽然在全局环境无法访问<code>outer</code>变量，但由于<code>Inner</code>函数可以访问，如果在全局环境中获取<code>Inner</code>函数的话，就可以访问<code>outer</code>变量了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> glob = <span class="string">'Global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> outer = <span class="string">'Outer'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> inner = <span class="string">'Inner'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = Outer(); <span class="comment">//这个func就等于Inner函数，这样func就能访问outer的值了。</span></span><br></pre></td></tr></table></figure>
<p>上述的<code>func</code>接受了<code>Outer</code>函数返回的<code>Inner</code>函数，所以<code>func</code>即可访问<code>Outer</code>函数中定义的<code>outer</code>变量了。举个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> outer = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        outer++;</span><br><span class="line">        <span class="built_in">console</span>.log(outer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = Outer();</span><br><span class="line"></span><br><span class="line">func(); <span class="comment">// 输出1</span></span><br><span class="line">func(); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>
<p>这就是外部读取内部变量的经典方式。这个<code>Inner</code>的内部函数，就叫做<strong>闭包</strong>。<code>闭包</code>简单来说就是函数内部的函数，如果一旦该内部函数被返回到别的作用域，那么这个内部函数就形成一个闭包。因为引用了函数内部的一些变量，所以可以在别的作用域中进行访问。</p>
<p>同一个闭包可以同时存在多个，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> outer = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        outer++;</span><br><span class="line">        <span class="built_in">console</span>.log(outer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = Outer();</span><br><span class="line"></span><br><span class="line">func(); <span class="comment">// 输出1</span></span><br><span class="line">func(); <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherFunc = Outer();</span><br><span class="line">anotherFunc(); <span class="comment">// 输出1</span></span><br><span class="line">anotherFunc(); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h2 id="2-闭包的副作用"><a href="#2-闭包的副作用" class="headerlink" title="2. 闭包的副作用"></a>2. 闭包的副作用</h2><p>首先由于闭包会携带包含它的作用域，所以闭包会比其他函数占用更多的内存。过度使用可能会导致内存泄漏。</p>
<p>另一方面，闭包还有一个副作用，就是闭包只能取得包含函数中任何变量的最后一个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 闭包</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现，<code>result</code>这个数组其实是一串闭包的数组，因为都引用了<code>i</code>这个变量。</p>
<p>表面上看，数组里的每一项运行后都能返回它们各自的索引值，从0-9，但其实，每次运行的结果都是10。因为这10个函数中都引用了<code>createFunctions</code>里边的<code>i</code>变量，这个变量在函数执行完成的时候为10，所以所有的结果都是10。如果想要改成预期的结果，则可以这样做来避免上述情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 定义一个立即执行函数，赋值i的一份副本到num，这个时候，每个函数都会引用num了，num从0-9</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，关于<code>this</code>对象，闭包有时候也会有一些需要注意的地方，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'The window'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object1 = &#123;</span><br><span class="line">    name: <span class="string">'Monar'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object2 = &#123;</span><br><span class="line">    name: <span class="string">'Sandy'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object3 = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.getName()); <span class="comment">// Monar</span></span><br><span class="line"><span class="built_in">console</span>.log(object2.getName()()); <span class="comment">// The window</span></span><br><span class="line"><span class="built_in">console</span>.log(object3.getName()()); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
<p>上述三个例子，<code>object1</code>是正常情况，<code>object2</code>调用<code>getName()()</code>后发现<code>this</code>的指向是全局的，因为<code>object2.getName()</code>执行后返回的是匿名函数<code>function(){return this.name}</code>，因为<strong>匿名函数的执行环境具有全局性</strong>，所以这个<code>this</code>指向全局环境中的<code>name</code>。如果想要返回的函数返回对象里边的<code>name</code>，那么就要像<code>object3</code>一样，构建一个闭包，引用内部的<code>this</code>，将值放到<code>that</code>中，然后返回调用即可。</p>
<h2 id="3-闭包的例子"><a href="#3-闭包的例子" class="headerlink" title="3. 闭包的例子"></a>3. 闭包的例子</h2><p>1 实现私有变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// add和get即为两个闭包，可以访问匿名函数内部的privateCounter属性</span></span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateCount++;</span><br><span class="line">        &#125;,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于privateCounter存在于匿名函数内部，所以除了app对象中包含的两个闭包方法外，没有任何方式可以访问privateCounter变量</span></span><br><span class="line">app.add();</span><br><span class="line"><span class="built_in">console</span>.log(app.get()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>2 knockout中的observable</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> far = ko.observable(<span class="string">'LinWei'</span>);</span><br><span class="line"></span><br><span class="line">far(); <span class="comment">// LinWei， 取值操作</span></span><br><span class="line"></span><br><span class="line">far(<span class="string">'ZiLiang'</span>); <span class="comment">// 赋值操作</span></span><br><span class="line"></span><br><span class="line">far(); <span class="comment">// ZiLiang，取值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码</span></span><br><span class="line">$.observable = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 闭包变量，保存在内存中，存储ko对象的值</span></span><br><span class="line">    <span class="keyword">var</span> v = value;</span><br><span class="line">    <span class="comment">// 返回闭包函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果有参数传进来，为赋值操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">            <span class="comment">// 且与上次的值不同的话，重新赋值</span></span><br><span class="line">            <span class="keyword">if</span> (v !== val) &#123;</span><br><span class="line">                v = val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回闭包供下次调用</span></span><br><span class="line">            <span class="keyword">return</span> closure;</span><br><span class="line">        <span class="comment">// 如果没有参数传进来，为取值操作，直接返回闭包存储的值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回闭包</span></span><br><span class="line">    <span class="keyword">return</span> closure;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3 未完待续…</p>
<h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献"></a>4. 参考文献</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">学习Javascript闭包(Closure) 阮一峰</a></li>
<li>Javascript高级程序设计(第五版) 第七章-函数表达式</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2017/01/06/state/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/06/state/" itemprop="url">React Quick Start - 5. State和生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-06T16:47:00+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="State和生命周期"><a href="#State和生命周期" class="headerlink" title="State和生命周期"></a>State和生命周期</h2><p>考虑之前时钟的例子，目前为止我们只学习了一种更新UI的方式，那就是通过调用<code>ReactDOM.render()</code>来渲染新的页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">            &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        element,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>这一章，我们将学习如何让<code>Clock</code>组件变成可复用的和可封装的，它将会自己设置计时器并且每一秒更新自己。</p>
<p>首先先对clock进行组件封装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">            &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;Clock date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125; /&gt;,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>但是，这个组件忽略了一个关键的需求：应该由<code>Clock</code>自己来设置一个计时器并且每秒更新UI，这是<code>Clock</code>的实现细节。</p>
<p>理想状态下，我们想要的效果是只写一次<code>Clock</code>，并让其自己进行更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Clock /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>要实现这个效果，我们需要给<code>Clock</code>组件添加”state”。</p>
<p>State和props很像，但是State是私有的，并且完全由组件自己来控制。</p>
<p>之前我们曾谈到过，组件以类的方式来定义的话有一些额外的特性。本地的state就属于这种特性，只有类方式定义的组件才有。</p>
<h3 id="将函数式组件改写为类方式"><a href="#将函数式组件改写为类方式" class="headerlink" title="将函数式组件改写为类方式"></a>将函数式组件改写为类方式</h3><p>将一个函数式组件改写为类组件需要五步：</p>
<ol>
<li>用相同的名字创建一个<code>ES6</code>的<code>class</code>，并且继承自<code>React.Component</code>。</li>
<li>添加一个空的方法<code>render()</code>。 </li>
<li>将函数组件的内部代码转移到<code>render()</code>方法内部。</li>
<li>替换<code>render()</code>方法内部的<code>props</code>属性为<code>this.props</code>。</li>
<li>删除空的函数声明。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，<code>Clock</code>组件现在已经从函数式定义转变为了类定义。这样一来，我们就可以使用一些额外的特性了，比如state和生命周期钩子。</p>
<h3 id="添加本地State"><a href="#添加本地State" class="headerlink" title="添加本地State"></a>添加本地State</h3><p>将<code>date</code>从props变为state需要三步：</p>
<p>1 将<code>render()</code>方法中的<code>this.props.date</code>替换为<code>this.state.date</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 为类添加一个构造函数<code>constructor</code>，并且声明和初始化<code>this.state</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们传递了<code>props</code>给基类构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类组件应该在任何时候都传递<code>props</code>参数给基类构造函数并且调用。</p>
<p>3 移除<code>&lt;Clock /&gt;</code>元素里边的<code>date</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Clock /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们稍后添加回来计时器相关的代码。</p>
<p>目前的组件如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Clock /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>下一步，我们将给<code>Clock</code>逐渐设置计时器，并且让它每一秒都进行更新。</p>
<h3 id="添加生命周期函数"><a href="#添加生命周期函数" class="headerlink" title="添加生命周期函数"></a>添加生命周期函数</h3><p>在拥有很多组件的应用中，有一点非常重要，那就是当组件摧毁的时候一定要释放其占用的资源。</p>
<p>我们想在<code>Clock</code>第一次渲染在DOM树中的时候设置一个定时器，这在react中叫做”挂载(monting)”。</p>
<p>同样的，我们也想在<code>Clock</code>在DOM树中移除的时候清除掉定时器，这在react中叫做”卸载(unmounting)”。</p>
<p>我们可以在组件类中声明一些特殊的方法，这些方法可以在组件挂载或者卸载的时候运行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法统称为”生命周期挂钩”。</p>
<p><code>componentDidMount()</code>挂钩函数会在组件渲染到DOM中之后执行，将计时器放到这里非常合适：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">        () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">        <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里我们将计时器的ID附在了<code>this</code>上边。</p>
<p><code>this.props</code>、由React来设置，<code>this.state</code>相比而言有着特殊的意义，你可以任意添加额外的字段到class中如果你需要存储一些额外信息，并且不需要用来作为显示输出。</p>
<p>如果不需要在<code>render()</code>方法中使用一些变量，那么不就应该放置到state中。</p>
<p>此外，我们还需要在<code>componentWillUnmount()</code>生命周期挂钩中清除掉计时器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来实现<code>tich()</code>方法，用来每秒更新时间。</p>
<p>这个方法将会使用<code>this.setState()</code>来更新组件的本地state状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">            () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">            <span class="number">1000</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Clock /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>到现在，这个时钟就可以正常工作了。</p>
<p>现在来快速回顾一下发生了什么以及这些方法调用的顺序：</p>
<ol>
<li>当<code>&lt;Clock /&gt;</code>传递给<code>ReactDOM.render()</code>的时候，React会调用<code>Clock</code>组件的构造函数。因为<code>Clock</code>需要显示当前时间，所以它用一个包含当前时间的对象来初始化<code>this.state</code>。之后我们还会更新这个state。</li>
<li>之后React调用<code>Clock</code>组件的<code>render()</code>方法。这一步React才知道需要在屏幕上展示什么内容。React接着更新DOM去匹配<code>Clock</code>的渲染输出。</li>
<li>当<code>Clock</code>组件的输出插入到DOM中的时候，React调用<code>componentDidMount()</code>方法。在这个方法中，<code>Clock</code>组件请求浏览器来设置一个定时器，每一秒钟调用一次<code>tick()</code>方法。</li>
<li>每一秒钟，浏览器都会调用<code>tick()</code>方法。这个方法中，<code>Clock</code>组件将一个包含当前时间的对象传递给<code>setState()</code>,以此来更新UI。通过<code>setState()</code>调用，React会知道state已经改变，然后再次调用<code>render()</code>方法去了解下一步要在屏幕上展示什么样的内容。这个时候，<code>render()</code>方法中的<code>this.state.date</code>会变化，所以渲染出来的结果将会包含更新过的时间。相应地，React更新DOM。</li>
<li>如果<code>Clock</code>组件从DOM中移除的话，React会调用<code>componentWillUnmount()</code>方法，这个时候计时器停止。</li>
</ol>
<h3 id="正确使用State"><a href="#正确使用State" class="headerlink" title="正确使用State"></a>正确使用State</h3><p>关于<code>setState()</code>,以下三点你必须知道。</p>
<h4 id="不要直接去更改State"><a href="#不要直接去更改State" class="headerlink" title="不要直接去更改State"></a>不要直接去更改State</h4><p>举个例子，直接去修改state的话不会重新渲染组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span>;</span><br></pre></td></tr></table></figure>
<p>如果要修改state，请使用<code>setState()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>唯一可以直接对<code>this.state</code>直接赋值的地方是构造函数。</strong></p>
<h4 id="State的更新可能是异步的"><a href="#State的更新可能是异步的" class="headerlink" title="State的更新可能是异步的"></a>State的更新可能是异步的</h4><p>React可能会在一次更新操作中批处理多个<code>setState()</code>调用。</p>
<p>因为<code>this.props</code>和<code>this.state</code>可能异步更新，所以你不应该依赖他们当前的值去计算将来的状态（state）。</p>
<p>举个例子，下边的代码更新计数器可能会失败：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了针对这种情况，有另一种调用<code>setState()</code>方法的方式，那就是不再传递一个对象给它，而是传递一个函数。这个函数接受前一个状态值作为第一个参数，第二个参数是执行更新操作的时候的props属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>上边使用的是箭头函数，当然使用常规的函数也可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">prevState, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: prevState.counter + props.increment</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="State的更新会被合并"><a href="#State的更新会被合并" class="headerlink" title="State的更新会被合并"></a>State的更新会被合并</h4><p>当调用<code>setState()</code>的时候，React会合并你提供给当前state的所有对象。</p>
<p>举个例子，你的state可能包含若干相互独立的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        posts: [],</span><br><span class="line">        comments: []</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后你可能会分别调用<code>setState()</code>来互不影响地更新它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            posts: response.posts</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            comments: response.comments</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并只是表面的，所以<code>this.setState({comments})</code>保证了<code>this.state.posts</code>的独立完整，但是完整替换了<code>this.state.comments</code>。</p>
<h3 id="数据流自上而下流动"><a href="#数据流自上而下流动" class="headerlink" title="数据流自上而下流动"></a>数据流自上而下流动</h3><p>无论是父组件还是子组件都无法知道一个确定的组件是有状态的还是无状态的，而且它们也不应该关注组件是以何种方式定义。</p>
<p>正因为如此，所以说state经常被认为是本地的或者封装的。对于任何组件，无论谁拥有它或设置它，都无法访问它的内部。</p>
<p>一个组件可以将其state以props的方式向下传递给其子组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式也适用于自定义组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;<span class="keyword">this</span>.state.date&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p><code>FormattedDate</code>组件可以接受<code>date</code>参数在其props中，并且不需要知道是否来自<code>Clock</code>组件的state或者props或者仅仅是被手动输入的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这通常被称为”自顶向下”或者”单向”的数据流。任何state都属于一些特定的组件，任何组件中的数据或者源于state的UI元素都只能影响该组件下游的子组件。</p>
<p>如果将一棵组件树想象成为props的瀑布，每一个组件的state都是一个额外的水源，这个水源可以并入瀑布任意一点，并且只能向下流动。</p>
<p>为了表示所有组件确实是相互隔离的，我们可以创建一个<code>App</code>组件来渲染三个<code>Clock</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Clock /&gt;</span><br><span class="line">            &lt;Clock /&gt;</span><br><span class="line">            &lt;Clock /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>每一个时钟都会设置自己的计时器，并且互不影响地进行更新。</p>
<p>在React应用中，无论一个组件是有状态的还是无状态的都被认为是一个组件的实现细节，都可能随着时间而改变。你可以在有状态的组件中使用无状态的组件，反过来也一样。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2017/01/05/component/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/05/component/" itemprop="url">React Quick Start - 4. 组件与Props</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-05T15:44:00+08:00">
                2017-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="组件与Props"><a href="#组件与Props" class="headerlink" title="组件与Props"></a>组件与Props</h2><p>组件可以将UI页面分割成为许多相互独立的、可复用的片段，从而使得考虑每一部分的设计时可以独立考虑。</p>
<p>概念上讲，组件类似于Javascript中的函数。组件接受任意的输入（称为<code>props</code>）并最终返回在屏幕上显示的React元素。</p>
<h3 id="函数式与类形式的组件"><a href="#函数式与类形式的组件" class="headerlink" title="函数式与类形式的组件"></a>函数式与类形式的组件</h3><p>最简单定义一个组件的方式是用Javascript的function:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边这个函数是一个合法的React组件，它接受一个”props”对象作为参数，并返回一个React元素。我们称这种组件为”函数式的组件”，因为它就是字面上的Javascrit函数。</p>
<p>另一种定义组件的方法是使用ES6中的<code>class</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两种组件在React里是完全等价的。利用<code>class</code>定义的组件会有一些额外的特性，下一章会重点讨论，目前为止都用函数式的组件来举例，因为简明一点。</p>
<h3 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h3><p>之前我们只遇到过React元素代表DOM标签的情况:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;div /&gt;;</span><br></pre></td></tr></table></figure>
<p>其实，元素也可以表示用户自定义的组件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;Welcome name="Sara" /&gt;;</span><br></pre></td></tr></table></figure>
<p>当React检测到一个元素代表的是一个用户自定义的组件的时候，它会将JSX的属性当做一个单对象传递给组件。我们称这个对象叫做”props”。</p>
<p>举个例子，下面的例子在页面上展示”Hello, Sara”:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = &lt;Welcome name="Sara" /&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.getElementById('root')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>现在重点来看下在这个例子中发生了什么：</p>
<ol>
<li>通过调用<code>ReactDOM.render()</code>来渲染<code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code>元素。</li>
<li>React 调用<code>Welcome</code>组件，并且将<code>{name: &#39;Sara&#39;}</code>作为props对象传入。</li>
<li><code>Welcome</code>组件返回<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>元素作为组件输出结果。</li>
<li>ReactDOM最终更新DOM，将<code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>元素显示。</li>
</ol>
<blockquote>
<p>警告：通常情况下，组件名称都以大写开头。举个例子，<code>&lt;div /&gt;</code>代表了一个普通的DOM元素标签，但是<code>&lt;Welcome /&gt;</code>代表的是一个组件，并且需要<code>Welcome</code>在作用域内。</p>
</blockquote>
<h3 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h3><p>组件在输出的时候也可以引用其他的组件。这可以让我们用组件抽象出各种层级的细节。一个按钮，一个表单，一个对话框等：在React应用中，所有的这些都是通过组件来表达的。</p>
<p>举个例子，我们可以通过创建一个<code>APP</code>组件来渲染多次<code>Welcome</code>组件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Welcome name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">            &lt;Welcome name=<span class="string">"Cahal"</span> /&gt;</span><br><span class="line">            &lt;Welcome name=<span class="string">"Edite"</span> /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>通常，React的应用拥有一个顶级的<code>App</code>组件。不过如果是将React集成进一个已经存在的应用里边，可能一开始是自底向上构建，比如从一个按钮一样的小组件开始，然后逐步向顶层构建。</p>
<blockquote>
<p>警告：组件必须返回一个单结点的根元素。这也是为什么上边将所有<code>&lt;Welcome /&gt;</code>放置在一个<code>&lt;div&gt;</code>里边的原因。</p>
</blockquote>
<h3 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h3><p>不必害怕将一个大的组件分解成为小的组件。</p>
<p>举个例子，考虑将下边的<code>Comment</code>组件抽取成小的组件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">                &lt;img className=<span class="string">"Avatar"</span> src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125;/&gt;</span><br><span class="line">                &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">                    &#123;props.author.name&#125;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">                &#123;props.text&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">                &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个组件接受<code>anthor</code>(一个对象),<code>text</code>(一个字符串)和<code>date</code>(一个日期类型)作为props,在一个社交媒体网站上描述一段评论信息。</p>
<p>这个组件很难去更改，因为所有的内容糅杂在一起了。这导致很难去复用组件里边的每一部分。让我们把这个组件里边的一些小的组件提取出来。</p>
<p>首先可以提取<code>Avatar</code>组件来表示头像:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;img className=<span class="string">"Avatar"</span> src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Avatar</code>组件并不关心<code>Comment</code>组件中渲染什么样的内容，这也是为什么传递给<code>Avatar</code>一个更加通用的名字：<code>user</code>而不是<code>author</code>。</p>
<p>推荐给props命名从这个组件自身作用的视角前去考虑，而不是这个组件将被用于什么样的场合。</p>
<p>现在可以将<code>Comment</code>组件稍微简化一点:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">                &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">                &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">                    &#123;props.author.name&#125;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">                &#123;props.text&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">                &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>下一步提取一个<code>UserInfo</code>组件来渲染用户的姓名，这个组件包含用户的头像和姓名:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">            &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">            &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">                &#123;props.user.name&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以让<code>Comment</code>组件进一步简化:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">            &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">            &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">                &#123;props.text&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">                &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>提取组件可能是一件比较繁琐的工作，但是在大的应用中，提取各种各样可复用的组件回报很大！</p>
<p>一个好的实践就是如果你的页面中某一部分被多次使用（比如<code>Button</code>,<code>Panel</code>,<code>Avatar</code>），或者这个组件自己很复杂（<code>App</code>,<code>FeedStory</code>,<code>Comment</code>）,那么将其提取成各种可复用的组件会是一个不错的选择。</p>
<h3 id="Props是只读的"><a href="#Props是只读的" class="headerlink" title="Props是只读的"></a>Props是只读的</h3><p>当以函数式或者类形式声明一个组件的时候，这个组件就无法改变它自己的props。看下边这个<code>sum</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种函数被称为纯函数，因为它并不改变输入的值，而且相同的输入下总是返回相同的结果。</p>
<p>相应的，还有一种非纯函数，这种函数会改变它输入的值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">account, amount</span>) </span>&#123;</span><br><span class="line">    account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React非常灵活，但是有一条很严格的规则：</p>
<p><strong>所有的React组件必须表现得像纯函数一样，不更改它们的props。</strong></p>
<p>当然，所有的应用都是动态的，跟随时间所变化。下一节，我们会介绍一个新的概念<code>state</code>。</p>
<p>在不违背上述规则的前提下，State允许React组件随着时间根据用户的动作、网络响应或者其他事件来做出变动。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2017/01/04/renderelem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/04/renderelem/" itemprop="url">React Quick Start - 3. 渲染元素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-04T15:25:00+08:00">
                2017-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h2><p><code>元素（Elements）</code>是构建React应用的最小单元。</p>
<p>一个元素来描述你希望屏幕上展现的UI元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure>
<p>与DOM元素不同的是，React元素是普通的对象，创建简单。React DOM更加关注更新与React元素匹配的DOM树。</p>
<blockquote>
<p>Tips: 一个常见的误区是将元素与组件(Components)弄混淆。元素只是构成组件的零部件。</p>
</blockquote>
<h3 id="渲染一个元素到DOM树中"><a href="#渲染一个元素到DOM树中" class="headerlink" title="渲染一个元素到DOM树中"></a>渲染一个元素到DOM树中</h3><p>首先假定在html文档中有一个<code>&lt;div&gt;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"root"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>我们把这个称为”root”DOM结点，其中嵌套的所有东西都将被React DOM来接管。</p>
<p>通过React构建的应用通常只有一个单root结点。如果要将React集成在一个已存在的应用里，那么可以拥有多个相互独立的DOM根节点。</p>
<p>将一个React元素渲染到根DOM结点中，需要借助<code>ReactDOM.render()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这会在页面上展示”Hello World”。</p>
<h3 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素"></a>更新已渲染的元素</h3><p>React的元素是<code>不可变</code>的。一旦创建了一个元素后就无法改变它的子节点或者属性。</p>
<p>一个元素就像是电影里边的一帧：它代表了一个UI元素在某一刻的展现。</p>
<p>就我们现在了解到的，唯一可以更新UI元素的方式就是创建一个新的元素，并通过<code>ReactDOM.render()</code>函数来渲染。</p>
<p>下边是一个时钟的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        element,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>setInterval()</code>函数每过一秒就会重新调用<code>ReactDOM.render()</code>来渲染一个新的元素到页面上。</p>
<blockquote>
<p>注意：实践中，大多数情况下React APP只调用<code>ReactDOM.render()</code>一次，在后边的章节中会学习如何利用具有状态的组件来封装代码。</p>
</blockquote>
<h3 id="React只在必要的时候才会更新"><a href="#React只在必要的时候才会更新" class="headerlink" title="React只在必要的时候才会更新"></a>React只在必要的时候才会更新</h3><p>React DOM会将当前元素以及其子元素和之前的状态进行比对，只有在状态确实改变的情况下才会做出必要的更新。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2016/12/30/jsxintro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/30/jsxintro/" itemprop="url">React Quick Start - 2. JSX 简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-30T10:10:00+08:00">
                2016-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h2><p>先看下这句声明：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure></p>
<p>以上这种标签语法既不是一个字符串也不是HTML。</p>
<p>这就是<code>JSX</code>，一种Javascript语法的一种扩展。官方推荐使用<code>JSX</code>和<code>React</code>搭配来描述UI组件。</p>
<p><code>JSX</code>产出<code>React</code>的<code>元素</code>。下边主要介绍<code>JSX</code>的基本使用。</p>
<h3 id="将表达式嵌入JSX"><a href="#将表达式嵌入JSX" class="headerlink" title="将表达式嵌入JSX"></a>将表达式嵌入JSX</h3><p>在<code>JSX</code>中可以使用<code>{}</code>来包含任何javascript表达式，比如说<code>2+2</code>，<code>user.name</code>或者方法调用<code>formatName(user)</code>等都是合法的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">'Harper'</span>,</span><br><span class="line">    lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">        Hello, &#123;formatName(user)&#125;!</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    element,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<h3 id="将JSX放入表达式中"><a href="#将JSX放入表达式中" class="headerlink" title="将JSX放入表达式中"></a>将JSX放入表达式中</h3><p>经过编译，<code>JSX</code>表达式会变为普通的Javascript对象。<br>这意味着你可以在if语句中和for循环中插入<code>JSX</code>语法，也可以将<code>JSX</code>赋值给变量、接受其为参数或者从函数中返回<code>JSX</code>表达式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="为JSX设定属性"><a href="#为JSX设定属性" class="headerlink" title="为JSX设定属性"></a>为JSX设定属性</h3><p>可以通过双引号包括的字符串字面量来作为<code>JSX</code>的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;div tabIndex="0"&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure>
<p>当然也可以通过<code>{}</code>包裹的Javascript表达式来作为属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="为JSX设定子元素"><a href="#为JSX设定子元素" class="headerlink" title="为JSX设定子元素"></a>为JSX设定子元素</h3><p>如果一个标签是空标签，可以使用闭合标签<code>/&gt;</code>来结束标签，像XML一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;</span><br></pre></td></tr></table></figure>
<p><code>JSX</code>标签可以包含子元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：由于JSX语法较之HTML更加接近于Javascript，所以React DOM使用驼峰命名的方式来命名属性名，以此来替换HTML中的属性。<br>举个例子比如<code>class</code>在JSX中必须写成<code>className</code>，<code>tabindex</code>必须写成<code>tabIndex</code>。</p>
</blockquote>
<h3 id="JSX可以阻止注入攻击"><a href="#JSX可以阻止注入攻击" class="headerlink" title="JSX可以阻止注入攻击"></a>JSX可以阻止注入攻击</h3><p>将用户输入嵌入JSX是安全的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>默认情况下，对于任何嵌入到JSX中的值，React DOM在渲染之前都会进行编码。因此，它确保了在你的应用中你无法注入任何没有明确写明的代码，因为任何东西都会在渲染前被转化成字符串。<br>这种方式可以阻止XSS（跨域站点攻击）。</p>
<h3 id="JSX代表了一种对象"><a href="#JSX代表了一种对象" class="headerlink" title="JSX代表了一种对象"></a>JSX代表了一种对象</h3><p>Babel通过转码会将JSX编译为<code>React.createElement()</code>的调用：</p>
<p>以下两种方式是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">        Hello, world!</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">        &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">    <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>React.createElement()</code>可以确保你写出bug更少的代码，它创造出的对象像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: this structure is simplified</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">    type: <span class="string">'h1'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        className: <span class="string">'greeting'</span>,</span><br><span class="line">        children: <span class="string">'Hello, world'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种对象称为<code>React元素</code>，你可以理解为他们就是页面上UI元素的描述信息。React解析这些对象，并通过他们来构建和更新DOM树。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2016/12/30/installation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/30/installation/" itemprop="url">React Quick Start - 1. 安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-30T10:05:00+08:00">
                2016-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>主要翻译的是React的官方文档<a href="https://facebook.github.io/react/docs/installation.html" target="_blank" rel="noopener">Quick Start</a>部分</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装React"><a href="#安装React" class="headerlink" title="安装React"></a>安装React</h3><p>官方推荐使用<code>Yarn</code>或者<code>npm</code>来管理前端依赖。</p>
<p>如果使用<code>Yarn</code>，可以这样安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure></p>
<p>如果使用<code>npm</code>，可以这样安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react react-dom</span><br></pre></td></tr></table></figure></p>
<h3 id="使用ES6和JSX"><a href="#使用ES6和JSX" class="headerlink" title="使用ES6和JSX"></a>使用ES6和JSX</h3><p>官方推荐使用<a href="https://babeljs.io/" target="_blank" rel="noopener"><code>Babel</code></a>转义器来编译React代码，这样可以在React中使用<code>ES6</code>和<code>JSX</code>的语法。<br><code>ES6</code>是最新一代的Javascript，它拥有诸多全新的特性与语法，能够使开发更加便捷轻松。<br><code>JSX</code>是Javascript语言的一种扩展，可以与React友好地进行协作。</p>
<p>在使用<code>babel</code>之前确保已经安装了<code>babel-preset-react</code>和<code>babel-preset-es2015</code>，并且在<code>.bablerc</code>中做好了配置。</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>官方推荐使用<code>webpack</code>或者<code>Browserify</code>等打包器来管理代码，一来可以让代码模块化，二来可以打包加载以减少加载时间。</p>
<p>下边是最小的一个React应用Hello World：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;/h1&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这段代码构造了一个包含<code>Hello, world!</code>字样的<code>h1</code>Dom元素,并且将这个元素渲染进了页面上一个id为root的元素里。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2016/06/20/LearnGit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/20/LearnGit/" itemprop="url">Learn Git</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-20T21:29:32+08:00">
                2016-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>记录一些常用的git命令</p>
</blockquote>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="comment">#全局配置</span></span><br><span class="line"></span><br><span class="line">git config --list <span class="comment">#配置清单</span></span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout <span class="comment">#设置别名checkout</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">help</span> <span class="comment">#帮助</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">#初始化仓库</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> [url] [another name] <span class="comment">#从远程仓库克隆</span></span><br><span class="line"></span><br><span class="line">git status <span class="comment">#查看当前状态</span></span><br><span class="line"></span><br><span class="line">git add [file path] <span class="comment">#跟踪当前某文件，纳入版本仓库，add就是放入暂存区的意思，如果是文件夹则会递归纳入</span></span><br><span class="line"></span><br><span class="line">git diff [--cached] <span class="comment">#查看修改文件之后还未暂存的变化，加了参数--cached是查看暂存之后与版本库的变化</span></span><br><span class="line"></span><br><span class="line">git commit [-m] [<span class="comment">#] #提交到版本库所有暂存区域的更新，-a参数会跳过暂存，直接将已跟踪的所有文件直接提交到版本库</span></span><br><span class="line"></span><br><span class="line">git rm [--cached] [file name] <span class="comment">#移除某个文件的跟踪，并将其从文件目录删除，如果加--cached参数的话只是从版本库移除跟踪</span></span><br><span class="line"></span><br><span class="line">git mv [file form] [file to] <span class="comment">#文件重命名</span></span><br><span class="line"></span><br><span class="line">git commit --amend <span class="comment">#修改最后一次提交</span></span><br><span class="line"></span><br><span class="line">git reset HEAD [file] <span class="comment">#取消暂存的文件</span></span><br><span class="line"></span><br><span class="line">git checkout -- [file] <span class="comment">#取消修改的文件，回到之前的提交状态文件</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>.gitignore 文件规则使用glob模式，所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p>
</blockquote>
<hr>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">#查看日志</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> -p -2 <span class="comment">#-p显示文件差异，-2显示最近两次</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span> <span class="comment">#显示摘要信息</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline/short/full/fuller <span class="comment">#提供格式化输出方式</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span> <span class="comment">#按照自定义格式输出log</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">"%h %s"</span> --graph <span class="comment">#图形化展示</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --since/until/after/before=2.weeks <span class="comment">#特定时间的log</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --author/committer</span><br></pre></td></tr></table></figure>
<blockquote>
<p>git log 选项 说明</p>
</blockquote>
<blockquote>
<p>-p 按补丁格式显示每个更新之间的差异。</p>
</blockquote>
<blockquote>
<p>–stat 显示每次更新的文件修改统计信息。</p>
</blockquote>
<blockquote>
<p>–shortstat 只显示 –stat 中最后的行数修改添加移除统计。</p>
</blockquote>
<blockquote>
<p>–name-only 仅在提交信息后显示已修改的文件清单。</p>
</blockquote>
<blockquote>
<p>–name-status 显示新增、修改、删除的文件清单。</p>
</blockquote>
<blockquote>
<p>–abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</p>
</blockquote>
<blockquote>
<p>–relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。</p>
</blockquote>
<blockquote>
<p>–graph 显示 ASCII 图形表示的分支合并历史。</p>
</blockquote>
<blockquote>
<p>–pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</p>
</blockquote>
<blockquote>
<p>format 选项 说明</p>
</blockquote>
<blockquote>
<p>%H 提交对象（commit）的完整哈希字串</p>
</blockquote>
<blockquote>
<p>%h 提交对象的简短哈希字串</p>
</blockquote>
<blockquote>
<p>%T 树对象（tree）的完整哈希字串</p>
</blockquote>
<blockquote>
<p>%t 树对象的简短哈希字串</p>
</blockquote>
<blockquote>
<p>%P 父对象（parent）的完整哈希字串</p>
</blockquote>
<blockquote>
<p>%p 父对象的简短哈希字串</p>
</blockquote>
<blockquote>
<p>%an 作者（author）的名字</p>
</blockquote>
<blockquote>
<p>%ae 作者的电子邮件地址</p>
</blockquote>
<blockquote>
<p>%ad 作者修订日期（可以用 -date= 选项定制格式）</p>
</blockquote>
<blockquote>
<p>%ar 作者修订日期，按多久以前的方式显示</p>
</blockquote>
<blockquote>
<p>%cn 提交者(committer)的名字</p>
</blockquote>
<blockquote>
<p>%ce 提交者的电子邮件地址</p>
</blockquote>
<blockquote>
<p>%cd 提交日期</p>
</blockquote>
<blockquote>
<p>%cr 提交日期，按多久以前的方式显示</p>
</blockquote>
<blockquote>
<p>%s 提交说明</p>
</blockquote>
<hr>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git remote [-v] <span class="comment">#查看远程仓库</span></span><br><span class="line"></span><br><span class="line">git remote add [short name] [url] <span class="comment">#添加远程仓库</span></span><br><span class="line"></span><br><span class="line">git fetch [remote name] <span class="comment">#从远程仓库抓取更新，只抓取，并不合并</span></span><br><span class="line"></span><br><span class="line">git push [remote name] [branch name] <span class="comment">#向远程仓库推送更新，推送必须别人没有更新才可以，否则需要先取回本地合并</span></span><br><span class="line"></span><br><span class="line">git remote show [remote name] <span class="comment">#查看远程仓库详情</span></span><br><span class="line"></span><br><span class="line">git remote rename [old name] [new name] <span class="comment">#重命名远程仓库名</span></span><br><span class="line"></span><br><span class="line">git remote rm [remote name] <span class="comment">#移除远程仓库</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git tag <span class="comment"># 查看现有标签</span></span><br><span class="line"></span><br><span class="line">git tag -a [v1.0] -m [<span class="comment">#] #新建带注释的标签</span></span><br><span class="line"></span><br><span class="line">git show [v1.0] <span class="comment">#查看某个版本信息</span></span><br><span class="line"></span><br><span class="line">git tag [v1.1] <span class="comment">#创建轻量级标签</span></span><br><span class="line"></span><br><span class="line">git tag -a [v1.0] [<span class="built_in">hash</span>] <span class="comment">#给特定提交添加标签</span></span><br><span class="line"></span><br><span class="line">git push [remote] [tag name]/[--tags] <span class="comment">#推送标签</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git branch [branch name] <span class="comment">#新建分支</span></span><br><span class="line"></span><br><span class="line">git checkout [branch name] <span class="comment">#切换分支</span></span><br><span class="line"></span><br><span class="line">git checkout -b [branch name] <span class="comment">#新建并切换到分支</span></span><br><span class="line"></span><br><span class="line">git merge [branch name] <span class="comment">#在当前分支上合并[branch name]分支</span></span><br><span class="line"></span><br><span class="line">git branch -d [branch name] <span class="comment">#删除分支</span></span><br><span class="line"></span><br><span class="line">git branch [-v]/[-vv] <span class="comment">#给出当前所有分支列表，*号代表当前所在分支</span></span><br><span class="line"></span><br><span class="line">git branch [--merged]/[--no-merged] <span class="comment">#查看那些分支合并进入了当前分支，即哪些分支是当前提交对象的直接上游</span></span><br><span class="line"></span><br><span class="line">git fetch [origin] <span class="comment">#获取服务器端的数据到本地，更新远程分支指向</span></span><br><span class="line"></span><br><span class="line">git push [origin] [master] <span class="comment">#向远程仓库推送自己的数据上去，更新远程分支的指向</span></span><br><span class="line"></span><br><span class="line">git checkout -b [<span class="built_in">local</span> branch name] [remote branch name] <span class="comment">#本地新建分支与远程对应</span></span><br><span class="line"></span><br><span class="line">git checkout --track [remote branch name] <span class="comment">#本地开始跟踪远程分支</span></span><br><span class="line"></span><br><span class="line">git push [origin]  :[branch name] <span class="comment">#删除远程分支名</span></span><br><span class="line"></span><br><span class="line">git rebase [origin/master] <span class="comment">#将自己的修改衍合到主干分支上去</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>git会维护一个HEAD的指针，指向当前分支的顶端。</p>
</blockquote>
<blockquote>
<p>切换分支最好保留一个干净的工作区域。</p>
</blockquote>
<blockquote>
<p>远程分支在本地无法移动，只是一个标记位。远程分支使用[origin]/[master]这种方式展现。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pymonar.github.io/2016/06/17/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="彭一">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柔水刻刀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/17/hello-world/" itemprop="url">你好，世界！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-17T21:29:32+08:00">
                2016-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&#160; &#160; &#160; &#160; &#160;这是个人站点的第一篇博客，作为一个程序员，当然要以Hello World来开启。<br>&#160; &#160; &#160; &#160; &#160;许久不曾提笔，竟完全不知道该写些什么。离开学校已经快三个月了，自己身上的坏习惯却依旧一点都没有少，浮躁，虚荣和拖延。这些坏习惯都阻止着自己成为一个优秀的人，如今借此机会立下flag，痛改恶习，重新做人！<br>&#160; &#160; &#160; &#160; &#160;要说这三个月一无是处倒也完全不是，至少Leetcode基本坚持刷下来了，虽然进度很慢，虽然才只刷了一半，但是至少，没有放弃。虽然曾经也一度因为苦思无解或是钻牛角尖等原因感到自己智商感人或者绝望愤怒，但是最终坚持了下来，并将坚持下去。虽然是前端程序员，但本质上还是个程序员，所以数据结构和算法，我不准备丢弃。也许成不了什么大神，至少别人问起我DFS和BFS时，我不会愧对做过软件学院的学生。<br>&#160; &#160; &#160; &#160; &#160;工作了两个月多，身边还是有很多大神，前端的，后端的，都有。他们身上都有很多闪光的地方，值得我虚心学习。甭管学历出身，毕竟自己还只是个弱鸡，受别人好的影响而吸收进自己的血液是我自己的优点，对此我还是很有信心。<br>&#160; &#160; &#160; &#160; &#160;虽然已经26岁，离开了年少轻狂，但毕竟才26岁，依旧有无限精彩和荣光。<br>&#160; &#160; &#160; &#160; &#160;加油！<br>&#160; &#160; &#160; &#160; &#160;2016.06.17 夜</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="彭一" />
            
              <p class="site-author-name" itemprop="name">彭一</p>
              <p class="site-description motion-element" itemprop="description">坚持与反复之后，柔水终成雕刀</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">彭一</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
